#!/bin/sh
#
# Wallet Omle shmollet
# see https://www.urbandictionary.com/define.php?term=Omle%20shmollet

set -o pipefail

help() {
cat <<EOF
Usage: wosh <command> [args]

Commands:
  init <privkey> <addr>
   - initialize a new config in current directory
  gini
   - generate a new privkey and address using bth.sh
     (which in turn uses the libbtc bitcointool)
  gen [number_of_blocks]
   - on regtest generate a number_of_blocks
     to configured address addr
  list
   - scan for txoutset of configured address
  send <address> <amount>
   - send <amount> to <address>, change goes back
     to the address configured at initialization
  getbalance
   - print current balance (including unmature)
  cons
   - consolidate outputs on the address
EOF
exit
}

test "$1" = "-h" && help
add=$(echo ${PWD} | md5sum | cut -b-7)
tmp=$PREFIX/tmp/wosh-$add
lock=$PREFIX/tmp/lock-$add
clean() {
  rm -rfv $tmp $lock 2>/dev/null
  exit
}
test "$1" = "clean" && clean

mkdir -p $tmp
until mkdir $lock 2>/dev/null; do sleep 0.5; done
lastf=$tmp/last
lastamountf=$tmp/lastamount
bbh=$(bch.sh getbestblockhash)
lbhf=$tmp/lastblockhash
lbh=$(cat $lbhf 2>/dev/null) && { test "$bbh" = "$lbh" || { rm -f $tmp/*last*; }; }
# list | grep $last && rm -f *last*

rcfile=$PWD/wosh.cat
init() {
  test -r $rcfile && { echo "$rcfile already exists!"; exit 1; }
  test "$1" = "" && { echo "Missing <privkey> argument!"; help; }
  test "$2" = "" && { echo "Missing <addr> argument!"; help; }

  cat > $rcfile <<-EOF
	privkey=$1
	addr=$2
	EOF
}

gini() {
  privkey=$(bth.sh -c genkey | grep WIF | cut -d: -f2)
  pub=$(bth.sh -c pubfrompriv -p $privkey | grep ^pubkey: | cut -d: -f2)
  bech32=$(bth.sh -c addrfrompub -k $pub | grep ^p2wpkh | cut -d: -f2)
  init $privkey $bech32
}

gen() {
  . $rcfile || exit 1
  bch.sh generatetoaddress ${1:-1} $addr
  rm $lastamountf $lasttxf 2>/dev/null
}

list() {
  #sto | jq -r '.unspents[] | .txid + " " + (.vout | tostring) + " " + (.amount | tostring) + " " + (.coinbase | tostring) + " " + (.height | tostring)' \
  #  | nicecat.sh $tmp/listnew-$$
  sto |
  {
    read l; read l; read l
    read l4
    { printf "height="; echo $l4 | cut -d: -f2 | tr -d ' ,'; } \
      > $rcfile-height
    read l; read l; read l 
    echo "$l4" > $tmp/lines
    cat \
    | tr -d '\n' | tr '{' '\n' \
    | cut -d, -f1,2,5,6,7 | tr ',' ':' | cut -d: -f2,4,6,8,10 \
    | tr -d ' "}\]' \
    | tr : " " \
    | sort -n -t " " -k 3
  } | nicecat.sh $tmp/listnew-$$
  mv $tmp/listnew-$$ $rcfile-list
}

compute() (
  result=$(echo "scale=8; $1" | bc)
  echo $result | grep -q '^-\.' && result=-0${result#-}
  echo $result | grep -q '^\.' && result=0$result
  echo $result
)

getbalance() {
  sto | jq .total_amount
# | nicecat.sh $tmp/total-new-$$
#  mv $tmp/total-new-$$ $tmp/total
}

genfromlist() (
  amount=0
  first=0
  total=0
  list >/dev/null
  test -r $tmp/height || echo "height=$(bch.sh getblockcount)" > $tmp/height
  . $tmp/height
  head -n 751 $rcfile-list | while read txid vout amount coinbase hei rest
  do
    test "$coinbase" = "true" && \
      test $hei -gt $(($height-100)) && continue
    test $first -eq 1 && printf '%s' ","
    first=1
    printf '%s' '''{"txid":"'$txid'","vout":'$vout'}'''
    total=$(compute "$total+$amount")
    echo $total > $tmp/totalnew
    mv $tmp/totalnew $tmp/total
  done > $tmp/utxonew
  mv $tmp/utxonew $tmp/utxo
)

genlastc() {
  txid=$(cat $lastf)
  bch.sh gettxout $txid 0 \
    | grep value | cut -d: -f2- | tr -d ' ,' \
    | safecat.sh $lastamountf
  echo $bbh | safecat.sh $lbhf
}

genfromlast() {
  txid=$(cat $lastf)
  genlastc
  cat $lastamountf > $tmp/totalnew
  mv $tmp/totalnew $tmp/total
  printf '%s' '''{"txid":"'$txid'","vout":0}''' > $tmp/utxonew
  mv $tmp/utxonew $tmp/utxo
}

gentx() (
  . $rcfile || exit 1
  amount=${1:-0}
  to=${2:-0}
  fake=${3:-0}
  fee=${4:-0}
  if test -r $lastf
  then genfromlast
  else genfromlist
  fi
  total=$(cat $tmp/total)
  total=$(compute "${total}-${amount}-(${fee}/100000000)")
  #echo $total >&2
  outs='''{"'$addr'":'$total'},{"'$to'":'$amount'}'''
  echo $total | safecat.sh $lastamountf
  echo $bbh > $lbhf-new
  mv $lbhf-new $lbhf
  #echo $outs >&2
  {
  cat <<-EOF
	[$(cat $tmp/utxo)]
	[$outs]
	0
	true
	EOF
  }
)

gentxf() {
  . $rcfile || exit 1
  fee=${1:-0}
  test "$fee" = "0" && fee=$(compute "118 * 5")
  faucet=${2:-0}
  fake=${3:-0}
  if test -r $lastf
  then genfromlast
  else genfromlist
  fi
  total=$(cat $tmp/total)
  total=$(compute "${total}-(($fee)/100000000)")
  #echo $total >&2
  if
    test "$faucet" = "0"
  then
    outs='''{"'$addr'":'$total'}'''
    outs='''{"'$addr'":'$total'},{"data":"6c6561726e20426974636f696e"}'''
    echo $total | safecat.sh $lastamountf
    echo $bbh > $lbhf-new
    mv $lbhf-new $lbhf
  else
    ranmin=$(compute "(((${RANDOM}+50000)*10)+1)/100000000")
    #echo $ranmin >&2
    rest=$(compute "${total}-$ranmin")
    #echo $rest >&2
    outs='''{"'$addr'":'$rest'},{"'$faucet'":'$ranmin'},{"data":"6c6561726e20426974636f696e"}'''
    echo $rest > $tmp/lastamountnew
    test "$fake" = "0" && {
      mv $tmp/lastamountnew $lastamountf
      echo $bbh > $lbhf-new
      mv $lbhf-new $lbhf
    }
  fi
  #echo $outs >&2
  {
  cat <<-EOF
	[$(cat $tmp/utxo)]
	[$outs]
	0
	true
	EOF
  }
}

gentxall() {
  . $rcfile || exit 1
  fee=${1:-0}
  addr=${2:-0}
  fake=${3:-0}
  if test -r $lastf
  then genfromlast
  else genfromlist
  fi
  total=$(cat $tmp/total)
  total=$(compute "${total}-(($fee)/100000000)")
  #echo $total >&2
  outs='''{"'$addr'":'$total'}'''
  echo $total | safecat.sh $lastamountf
  echo $bbh > $lbhf-new
  mv $lbhf-new $lbhf
  #echo $outs >&2
  {
  cat <<-EOF
	[$(cat $tmp/utxo)]
	[$outs]
	0
	true
	EOF
  }
}

# sendall <addr> - sends all to <addr> with minimal fee
sendall() {
  fee=$(gentxall ${2:-"0"} ${1:-"0"} 1 \
    | crt | srt | drt | grep vsize | cut -d: -f2 | tr -d ' ,"')
  #echo $fee >&2
  gentxall ${2:-$fee} ${1:-0} | crt | srt | sert | nicecat.sh $lastf-new
  test -s $lastf-new && mv $lastf-new $lastf
  echo $bbh | safecat.sh $lbhf
}

# send <addr> <amount> - sends <amount> to <addr>, change back here
send() (
  size=$(gentx ${2:-0} ${1:-0} 1 \
    | crt | srt | drt | grep vsize | cut -d: -f2 | tr -d ' ,"')
  fee=$(bch.sh estimatesmartfee 1 \
    | compute "$(grep -m1 feerate | cut -d: -f2- | tr -d '. ",')/1000*$size")
  #echo $fee
  #exit
  #fee=$(gentx ${2:-"0"} ${1:-"0"} 1 \
  #  | crt | srt | drt | grep vsize | cut -d: -f2 | tr -d ' ,"')
  #echo $fee >&2
  gentx ${2:-0} ${1:-0} 0 $fee | crt | srt | sert | nicecat.sh $lastf-new
  #gentx 0 ${1:-0} | crt | srt | sert | nicecat.sh $lastf-new
  test -s $lastf-new && {
    mv $lastf-new $lastf
    echo $bbh > $lbhf-new
    mv $lbhf-new $lbhf
  }
)

# faucet <addr> - sends from faucet to <addr>, change back to faucet
faucet() {
  size=$(gentxf ${2:-0} ${1:-0} 1 \
    | crt | srt | drt | grep vsize | cut -d: -f2 | tr -d ' ,"')
  fee=$(bch.sh estimatesmartfee 1 \
    | compute "$(grep -m1 feerate | cut -d: -f2- | tr -d '. ",')/1000*$size")
  #fee=$(gentxf ${2:-"0"} ${1:-"0"} 1 \
  #  | crt | srt | drt | grep vsize | cut -d: -f2 | tr -d ' ,"')
  #echo $fee >&2
  gentxf ${2:-$fee} ${1:-0} | crt | srt | sert | nicecat.sh $lastf-new
  #gentxf 0 ${1:-0} | crt | srt | sert | nicecat.sh $lastf-new
  test -s $lastf-new && {
    mv $lastf-new $lastf
    echo $bbh > $lbhf-new
    mv $lbhf-new $lbhf
  }
}
# ssend <addr> - sends from faucet to <addr>, change back to faucet
#  using a smart 1 block fee
ssend() (
  size=$(gentx ${2:-0} ${1:-0} 1 \
    | crt | srt | drt | grep vsize | cut -d: -f2 | tr -d ' ,"')
  fee=$(bch.sh estimatesmartfee 1 \
    | compute "$(grep -m1 feerate | cut -d: -f2- | tr -d '. ",')/1000*$size")
  #echo $fee >&2
  gentx ${2:-$fee} ${1:-0} | crt | srt | sert | nicecat.sh $lastf-new
  #gentx 0 ${1:-0} | crt | srt | sert | nicecat.sh $lastf-new
  test -s $lastf-new && {
    mv $lastf-new $lastf
    echo $bbh > $lbhf-new
    mv $lbhf-new $lbhf
  }
)

cons() {
  . $rcfile || exit 1
  gentx $addr
}

consagen() {
  cons
  gen
}

print() {
  . $rcfile || exit 1
  echo $addr
}

# Misc functions to ease typing

crt() {
  bch.sh -stdin createrawtransaction
}

drt() {
  bch.sh -stdin decoderawtransaction
}

srt() {
  . $rcfile || exit 1
  {
  cat
  echo '''["'$privkey'"]'''
  } | bch.sh -stdin signrawtransactionwithkey \
    | grep '"hex"' \
    | cut -d: -f2- \
    | tr -d ' ,"'
}

sert() {
  {
  cat
  echo 0
  } | bch.sh -stdin sendrawtransaction
}

sto() {
  . $rcfile || exit 1
  bch.sh scantxoutset start '''["addr('$addr')"]'''
}

"$@"

rmdir $lock 2>/dev/null
